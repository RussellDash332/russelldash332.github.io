<!DOCTYPE HTML>

<html>
<head>
<title>Fenwick Trees Made Easy!</title>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1, user-scalable=no" name="viewport"/>
<link href="../assets/css/main.css" rel="stylesheet"/>
<link href="../media/russell.png" rel="icon"/>
</head>
<body class="is-preload">
<section id="header">
<header>
<a class="active" href="https://russelldash332.github.io/">
<span class="image avatar"><img alt="" src="../media/profile.jpg"/></span>
<h1 id="logo">Russell Saerang</h1>
</a>
<p>NUS Data Science and Analytics 2024</p>
</header>
<nav id="nav">
<ul>
<li><a class="active" href="index.html">Posts</a></li>
</ul>
</nav>
<footer>
<ul class="icons">
<li><a class="icon brands fa-linkedin-in" href="https://www.linkedin.com/in/nicholasrussellsaerang/" rel="noopener noreferrer" target="_blank"><span class="label">LinkedIn</span></a></li>
<li><a class="icon brands fa-instagram" href="https://www.instagram.com/russellsaerang2702/" rel="noopener noreferrer" target="_blank"><span class="label">Instagram</span></a></li>
<li><a class="icon brands fa-github" href="https://github.com/RussellDash332/" rel="noopener noreferrer" target="_blank"><span class="label">Github</span></a></li>
<li><a class="icon brands fa-medium-m" href="https://medium.com/@russellsaerang" rel="noopener noreferrer" target="_blank"><span class="label">Medium</span></a></li>
<li><a class="icon solid fa-envelope" href="mailto:russellsaerang@gmail.com"><span class="label">Email</span></a></li>
</ul>
</footer>
</section>
<div id="wrapper">
<div id="main">
<section id="post">
<div class="image main" data-position="center">
<img alt="" src="../media/banner.jpg"/>
</div>
<div class="container"><div class="post-container"><h2>Fenwick Trees Made Easy!</h2>
<div class="date"><p>28 July 2024</p></div><p>Let’s start with an array <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi></mrow></math> of size <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>N</mi></mrow></math>, each entry is initially zero. Suppose that over time, I want to support these operations on the array:</p><ol>
<li>Add all indices of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi></mrow></math> in range <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false">[</mo><mi>l</mi><mo>,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow></math> by an integer <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math>, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>0</mn><mo>≤</mo><mi>l</mi><mo>≤</mo><mi>r</mi><mo>&lt;</mo><mi>N</mi></mrow></math></li>
<li>Find the sum of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo stretchy="false">[</mo><mi>l</mi><mo>.</mo><mo>.</mo><mi>r</mi><mo stretchy="false">]</mo></mrow></math>, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>0</mn><mo>≤</mo><mi>l</mi><mo>≤</mo><mi>r</mi><mo>&lt;</mo><mi>N</mi></mrow></math></li>
</ol><p>We can do this naively with a single for loop, right? This means each query type can be done in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></math> time. However, what if I tell you that there is a data structure that can support both these operations in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mi>N</mi><mo stretchy="false">)</mo></mrow></math> time? Let me introduced you to <strong>Fenwick trees</strong>, also called as <strong>binary indexed trees (BIT)</strong>!</p><h3>Update and Query</h3>
<p>Before we begin, let me introduce you to the concept of update and query operations. The first operation mentioned in the prologue is an update operation, whereas the second one is a query operation. On specific scenarios where it is guaranteed that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>l</mi><mo>=</mo><mi>r</mi></mrow></math>, we call these operations <em>point operations</em>, otherwise they are <em>range operations</em>. Therefore, Fenwick trees are capable of range updates (RU) and range queries (RQ), as well as point updates (PU) and point queries (PQ).</p><h3>The Classic PURQ</h3>
<p>I would like to dive straight to the PURQ version of the Fenwick tree which is the most commonly used version.</p><p>You can also test your own implementation of the PURQ Fenwick tree on this Kattis problem: <a href="https://open.kattis.com/problems/fenwick">Fenwick Tree</a>.</p><p>The PURQ Fenwick tree utilizes another array (let’s call this array <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi></mrow></math>) of size <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow></math> to support 1-based indexings. The main concept of Fenwick trees is the use of least significant bits (LSBs) to indicate which indices on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi></mrow></math> stores the value of a particular index on the original array.</p><p>For example, the least significant of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>10</mn></mrow></math> is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>2</mn></mrow></math> because <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>10</mn><mo>=</mo><mo stretchy="false">(</mo><mn>1010</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow></math> and therefore the LSB here is the rightmost 1-bit which is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>2</mn></mrow></math>. To quickly get the LSB of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math>, we simply evaluate <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mi>&amp;</mi><mo stretchy="false">(</mo><mo>−</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math>, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&amp;</mi></mrow></math> is the binary AND operation.</p><p>Now, how do we determine which indices of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi></mrow></math> that store <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow></math> for a particular index <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>i</mi></mrow></math>?</p><ul>
<li>Start with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>=</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow></math> (add 1 since the Fenwick tree array is 1-based)</li>
<li>Repeat the following as long as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>≤</mo><mi>N</mi></mrow></math>:<ul>
<li>Store <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow></math></li>
<li>Add <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> by the LSB of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math></li>
</ul>
</li>
</ul><p>For example, suppose <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>N</mi><mo>=</mo><mn>8</mn></mrow></math>. This means <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo stretchy="false">[</mo><mn>4</mn><mo stretchy="false">]</mo></mrow></math> is stored in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo stretchy="false">[</mo><mn>5</mn><mo stretchy="false">]</mo><mo>,</mo><mi>F</mi><mo stretchy="false">[</mo><mn>6</mn><mo stretchy="false">]</mo><mo>,</mo><mi>F</mi><mo stretchy="false">[</mo><mn>8</mn><mo stretchy="false">]</mo></mrow></math>. This is because <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>6</mn><mo>=</mo><mn>5</mn><mo>+</mo><mi>L</mi><mi>S</mi><mi>B</mi><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>8</mn><mo>=</mo><mn>6</mn><mo>+</mo><mi>L</mi><mi>S</mi><mi>B</mi><mo stretchy="false">(</mo><mn>6</mn><mo stretchy="false">)</mo></mrow></math>. For the rest of indices, do take a look at the following visualization below (indices of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi></mrow></math> are in pink text).</p><p><img alt="fenwick1" object-fit="contain" src="media/fenwick1.png" width="50%"/></p><p>Therefore, when adding <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow></math> by some integer <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math>, we simply do the same to all the indices of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi></mrow></math> that stores <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow></math>.</p><p>As for the range query for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo stretchy="false">[</mo><mi>l</mi><mo>.</mo><mo>.</mo><mi>r</mi><mo stretchy="false">]</mo></mrow></math>, let’s start with querying the prefix sum, meaning <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>l</mi><mo>=</mo><mn>0</mn></mrow></math>. Similarly, we also make use of the LSB of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow></math>, but instead of adding it until it exceeds <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>N</mi></mrow></math>, we keep subtracting until it becomes <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>0</mn></mrow></math>.</p><p>For example, we want to query the sum of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo stretchy="false">[</mo><mn>0</mn><mo>.</mo><mi>.5</mi><mo stretchy="false">]</mo></mrow></math>, so we start with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>=</mo><mn>5</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>6</mn></mrow></math>, and then we keep adding <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow></math> to our answer and subtract <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>L</mi><mi>S</mi><mi>B</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> until <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> equals <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>0</mn></mrow></math>. Therefore, for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>r</mi><mo>=</mo><mn>5</mn></mrow></math> we have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo stretchy="false">[</mo><mn>6</mn><mo stretchy="false">]</mo><mo>+</mo><mi>F</mi><mo stretchy="false">[</mo><mn>4</mn><mo stretchy="false">]</mo><mo>+</mo><mi>F</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow></math> as our final answer because <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>4</mn><mo>=</mo><mn>6</mn><mo>−</mo><mi>L</mi><mi>S</mi><mi>B</mi><mo stretchy="false">(</mo><mn>6</mn><mo stretchy="false">)</mo></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>0</mn><mo>=</mo><mn>4</mn><mo>−</mo><mi>L</mi><mi>S</mi><mi>B</mi><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo></mrow></math>.</p><p>To wrap up, we can now generalize to any value of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>l</mi></mrow></math> by subtracting the sum of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo stretchy="false">[</mo><mn>0</mn><mo>.</mo><mo>.</mo><mi>r</mi><mo stretchy="false">]</mo></mrow></math> with the sum of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo stretchy="false">[</mo><mn>0</mn><mo>.</mo><mo>.</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></math>.</p><p>Some of you might wonder what happens if the example <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>N</mi></mrow></math> isn’t a power of 2, and Fenwick tree will still work in this case (image below shows the case when <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>N</mi><mo>=</mo><mn>11</mn></mrow></math>).</p><p><img alt="fenwick3" object-fit="contain" src="media/fenwick3.png" width="50%"/></p><h3>Supporting RU</h3>
<h4>RUPQ</h4>
<p>To support range updates optimally, we have to change the structure of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi></mrow></math> to some extent. Let’s start with reimplementing <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi></mrow></math> such that it supports RUPQ first, then we can extend it to support RURQ.</p><p>We revisit the example when <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>N</mi><mo>=</mo><mn>8</mn></mrow></math>. Suppose I want to add <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo stretchy="false">[</mo><mn>1</mn><mo>.</mo><mi>.4</mi><mo stretchy="false">]</mo></mrow></math> by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>3</mn></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo stretchy="false">[</mo><mn>2</mn><mo>.</mo><mi>.6</mi><mo stretchy="false">]</mo></mrow></math> by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>5</mn></mrow></math>. Our actual array <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi></mrow></math> should look something like this:</p><p><img alt="fenwick2" object-fit="contain" src="media/fenwick2.png" width="50%"/></p><p>Let’s have another array <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>B</mi></mrow></math> of size <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow></math>. To resemble adding <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo stretchy="false">[</mo><mn>1</mn><mo>.</mo><mi>.4</mi><mo stretchy="false">]</mo></mrow></math> by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>3</mn></mrow></math>, we simply add <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>B</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></math> by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>3</mn></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>B</mi><mo stretchy="false">[</mo><mn>5</mn><mo stretchy="false">]</mo></mrow></math> by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>−</mo><mn>3</mn></mrow></math>. Similarly, we also add <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>B</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo></mrow></math> by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>5</mn></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>B</mi><mo stretchy="false">[</mo><mn>7</mn><mo stretchy="false">]</mo></mrow></math> by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>−</mo><mn>5</mn></mrow></math>. So, for every operation that adds <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo stretchy="false">[</mo><mi>l</mi><mo>.</mo><mo>.</mo><mi>r</mi><mo stretchy="false">]</mo></mrow></math> by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math>, we add <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>B</mi><mo stretchy="false">[</mo><mi>l</mi><mo stretchy="false">]</mo></mrow></math> by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>B</mi><mo stretchy="false">[</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></math> by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>−</mo><mi>x</mi></mrow></math>.</p><p>To answer the point query operations, we simply take the prefix sum of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>B</mi></mrow></math>. For example to query the value <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo></mrow></math>, we’re basically querying the sum of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>B</mi><mo stretchy="false">[</mo><mn>0</mn><mo>.</mo><mi>.2</mi><mo stretchy="false">]</mo></mrow></math>. Therefore, for every operation that queries <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow></math>, we simply query for the sum of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>B</mi><mo stretchy="false">[</mo><mn>0</mn><mo>.</mo><mo>.</mo><mi>i</mi><mo stretchy="false">]</mo></mrow></math>.</p><p><img alt="fenwick5" object-fit="contain" src="media/fenwick5.png" width="50%"/></p><p>Based on the examples above, we can use a PURQ Fenwick tree on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>B</mi></mrow></math> to support RUPQ on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi></mrow></math>. If we want to add <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo stretchy="false">[</mo><mi>l</mi><mo>.</mo><mo>.</mo><mi>r</mi><mo stretchy="false">]</mo></mrow></math> by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math>, we basically perform two point updates on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>B</mi></mrow></math> as explained previously, while doing a point query on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi></mrow></math> is basically performing a (prefix) range query on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>B</mi></mrow></math>.</p><h4>RURQ</h4>
<p>And now, the extension from RUPQ to RURQ!</p><p>Given the original array <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi></mrow></math> and the transformed array <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>B</mi></mrow></math> as what we see on the RUPQ case, we add another transformed array <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>C</mi></mrow></math> to handle the extra terms.</p><p>Recall that for every operation that adds <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo stretchy="false">[</mo><mi>l</mi><mo>.</mo><mo>.</mo><mi>r</mi><mo stretchy="false">]</mo></mrow></math> by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math>, we add <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>B</mi><mo stretchy="false">[</mo><mi>l</mi><mo stretchy="false">]</mo></mrow></math> by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>B</mi><mo stretchy="false">[</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></math> by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>−</mo><mi>x</mi></mrow></math>. Now, we also add <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>C</mi><mo stretchy="false">[</mo><mi>l</mi><mo stretchy="false">]</mo></mrow></math> by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mi>·</mi><mo stretchy="false">(</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>C</mi><mo stretchy="false">[</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></math> by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>−</mo><mi>x</mi><mi>·</mi><mi>r</mi></mrow></math>. The rigorous explanation on why one might come up with such structure can be found in <a href="https://cp-algorithms.com/data_structures/fenwick.html#3-range-update-and-range-query">this article by CP Algorithms</a>.</p><p><img alt="fenwick4" object-fit="contain" src="media/fenwick4.png" width="100%"/></p><p>Finally, to obtain the prefix range sum of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi></mrow></math>, we perform the following calculation.</p><p>​<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>r</mi></mrow></msubsup><mi>A</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>r</mi><mi>·</mi><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>r</mi></mrow></msubsup><mi>B</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>r</mi></mrow></msubsup><mi>C</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow></math></p><p>This means</p><p>​<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>l</mi></mrow><mrow><mi>r</mi></mrow></msubsup><mi>A</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>r</mi><mi>·</mi><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>r</mi></mrow></msubsup><mi>B</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>l</mi><mi>·</mi><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>l</mi></mrow></msubsup><mi>B</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>l</mi></mrow><mrow><mi>r</mi></mrow></msubsup><mi>C</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow></math></p><p>In conclusion, we can use two PURQ Fenwick trees on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>B</mi></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>C</mi></mrow></math> respectively to support RURQ on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi></mrow></math>. If we want to add <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo stretchy="false">[</mo><mi>l</mi><mo>.</mo><mo>.</mo><mi>r</mi><mo stretchy="false">]</mo></mrow></math> by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math>, we basically perform two point updates each on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>B</mi></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>C</mi></mrow></math> as explained, while doing a range query on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi></mrow></math> is basically performing TWO (prefix) range queries on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>B</mi></mrow></math> and also on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>C</mi></mrow></math>.</p><h3>Other Binary Operations</h3>
<p>The addition operation is not the only operation Fenwick trees can support. In fact, there are more (associative) binary operations that can be used as an example.</p>
<h4>XOR</h4>
<p>The main algorithm and array structure remains the same, depending whether you need the PURQ version, the RUPQ version, or the RURQ version. The only difference is that the addition operation is changed into the binary XOR operation. So, instead of adding elements by some integer <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math>, you apply XOR on these elements by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math>.</p><p>Here’s a Kattis problem that you can try out using XOR Fenwick trees: <a href="https://open.kattis.com/problems/magicallights">Association of Cats and Magical Lights</a>.</p><h4>Min or Max</h4>
<p>Though it is more advisable to support range operations involving minimum/maximum using segment trees, we can also perform such using Fenwick trees.</p><p>Since we can no longer use the prefix trick like the case for XOR and addition to answer range queries, we need to revamp things to some extent again. (Note that for addition and XOR, we can obtain <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>l</mi><mo>.</mo><mo>.</mo><mi>r</mi><mo stretchy="false">)</mo></mrow></math> given <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo>.</mo><mo>.</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo>.</mo><mo>.</mo><mi>r</mi><mo stretchy="false">)</mo></mrow></math>)</p><p>We now use an array of size <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>2</mn><mi>N</mi></mrow></math> instead of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow></math>, and the operations mainly involves simple bitshifts (or multiplication/division by 2) instead of computing LSBs like we used to do on the classic PURQ example.</p><p>More details can be seen at the Python code attached on <strong>the last section of this article</strong>.</p><h3>Limitations</h3>
<p>Since the main data structure used on Fenwick trees are arrays, we can see that it can hold up to a limited number of elements. Realistically speaking, for programs that are timed under 1 second, you can contain at most about <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msup><mn>10</mn><mn>6</mn></msup></mrow></math> elements. To support potentially way more elements than that, I suggest using (dynamic) segment trees which Fenwick trees are a subset of.</p><p>Similarly, some operations that are not (that) binary nor associative require segment trees to implement instead of Fenwick trees. For example, the second largest element in a range.</p><h3>Python Code</h3>
<p>I always keep my (exclusively Python) data structures and algorithms templates on this code repository: <a href="https://github.com/RussellDash332/pytils">pytils</a>.</p><p>Specifically for this article, here are two templates that would help:</p><ul>
<li><a href="https://github.com/RussellDash332/pytils/blob/main/fenwick_tree_rsq.py">Sum update/query</a>: PURQ, RURQ</li>
<li><a href="https://github.com/RussellDash332/pytils/blob/main/fenwick_tree_rmq.py">Min/max update/query</a>: PURQ, RUPQ</li>
</ul></div></div>
</section>
<section id="footer">
<div class="container">
<ul class="copyright">
<li>© Russell Saerang 2024. All rights reserved.</li>
<li>Design: <a href="http://html5up.net" rel="noopener noreferrer" target="_blank">HTML5 UP</a></li>
<li>Illustration: <a href="http://linkedin.com" rel="noopener noreferrer" target="_blank">LinkedIn</a> and <a href="http://unsplash.com" rel="noopener noreferrer" target="_blank">Unsplash</a></li>
</ul>
</div>
</section>
</div>
<script src="../assets/js/jquery.min.js"></script>
<script src="../assets/js/jquery.scrollex.min.js"></script>
<script src="../assets/js/jquery.scrolly.min.js"></script>
<script src="../assets/js/browser.min.js"></script>
<script src="../assets/js/breakpoints.min.js"></script>
<script src="../assets/js/util.js"></script>
<script src="../assets/js/main.js"></script>
</div></body>
</html>