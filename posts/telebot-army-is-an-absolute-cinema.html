<!DOCTYPE HTML>

<html>
<head>
<title>Telebot army is an absolute cinema</title>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1, user-scalable=no" name="viewport"/>
<link href="../assets/css/main.css" rel="stylesheet"/>
<link href="../media/russell.png" rel="icon"/>
</head>
<body class="is-preload">
<section id="header">
<header>
<a class="active" href="https://russelldash332.github.io/">
<span class="image avatar"><img alt="" src="../media/profile.jpg"/></span>
<h1 id="logo">Russell Saerang</h1>
</a>
<p>NUS Data Science and Analytics 2024, Systems Analyst at PSA Singapore</p>
</header>
<nav id="nav">
<ul>
<li><a class="active" href="index.html">Posts</a></li>
</ul>
</nav>
<footer>
<ul class="icons">
<li><a class="icon brands fa-linkedin-in" href="https://www.linkedin.com/in/nicholasrussellsaerang/" rel="noopener noreferrer" target="_blank"><span class="label">LinkedIn</span></a></li>
<li><a class="icon brands fa-instagram" href="https://www.instagram.com/russellsaerang2702/" rel="noopener noreferrer" target="_blank"><span class="label">Instagram</span></a></li>
<li><a class="icon brands fa-github" href="https://github.com/RussellDash332/" rel="noopener noreferrer" target="_blank"><span class="label">Github</span></a></li>
<li><a class="icon brands fa-medium-m" href="https://medium.com/@russellsaerang" rel="noopener noreferrer" target="_blank"><span class="label">Medium</span></a></li>
<li><a class="icon solid fa-envelope" href="mailto:russellsaerang@gmail.com"><span class="label">Email</span></a></li>
</ul>
</footer>
</section>
<div id="wrapper">
<div id="main">
<section id="post">
<div class="image main" data-position="center">
<img alt="" src="../media/banner.jpg"/>
</div>
<div class="container"><div class="post-container"><h2>Telebot army is an absolute cinema</h2>
<div class="date"><p>6 August 2025</p></div>
<h3>Preface: 2022</h3>
<p>It was the COVID era where everything was online, thus the rise of Telegram scammers trying to add random users to a particular set of scam and/or spam investment group chats. It was very disturbing for users who did not set up their privacy settings properly.</p>
<p>One of my friends was an unfortunate victim of the frequent spams. While I donâ€™t get those invitations as often as him at that time, I was also looking for a funny way to deal with this. After all, one should live a little, right?</p>
<p>One night, I proposed to him if we can make use of Telegram bots (known as <em>telebots</em>), a topic that we were both learning on, to deal with the spammers. In summary, we make use of a telebot army and spam back the group we were invited to if thereâ€™s an access loophole. This doesnâ€™t solve the problem as a whole, but itâ€™ll be definitely a funny victory once it works. I think he liked the idea, so we continued working on this silly mini-project.</p>
<h3>How itâ€™s done</h3>
<h4>BotFather</h4>
<p>First and foremost, you need to make the bots using BotFather on Telegram.</p>
<p><img alt="botfather" object-fit="contain" src="media/botfather.JPG" width="50%"/></p>
<p>The steps of creating a single bot is rather simple:</p>
<ol>
<li>Type <code>/newbot</code> to BotFather.</li>
<li>Choose a display name for the bot. This is not the Telegram bot handle, but rather what name do you want the bot to be displayed as.</li>
<li>Next, the bot handle. You only need to ensure that this handle ends with the word <code>bot</code> (case-insensitive), like <code>tetrisBoT</code> or <code>tetris_bot</code>. You must ensure that this handle is unique: since the handles are case-insensitive, <code>tetrisbot</code> and <code>tetrisBOT</code> are the same handle.</li>
<li>Do <code>/setprivacy</code> on the bot and set to <code>Disable</code> so it can send messages to the target chat. I personally think this is an optional step and only required if I canâ€™t send the bot messages to the target chat.</li>
</ol>
<p>If you want to save the time to come up with a unique bot handle, you can using the RNG script below.</p>
<pre><code class="language-python">from random import choice
from string import ascii_letters
print(''.join(choice(ascii_letters) for _ in range(20)) + '_bot')
</code></pre>
<p>The script generates a random 20-letter alphabetical string added with the <code>_bot</code> suffix.</p>
<p>Once the steps are complete, BotFather will give you an <strong>HTTP API token</strong>, which will be required for our next step. The token should look something like <code>0123456789:abcdefgh_ijklmno</code>. As prompted, keep them secure and store it safely, so if you decide to publish your Python script, mask the tokens first.</p>
<p>Finally, we simply rinse and repeat until youâ€™ve had sufficiently many bots to form your telebot army.</p>
<h4>Python</h4>
<p>Next, you need a Python script to execute the whole project. You only need these three modules, which you have to import on the very first line of your Python script.</p>
<pre><code class="language-python">import requests, time, threading
</code></pre>
<p><code>requests</code> is used to make internet connection requests like API calls, and you need to install this package beforehand. <code>time</code> is built-in and will be used for time-related functions like sleeping or querying the current Unix timestamp. <code>threading</code> is used to run multiple processes from the same code in your device.</p>
<p>Now we need to find the target chat ID to put the telebot army into. To do this, you are required to access Telegram Web instead of Telegram Desktop (or the mobile app).</p>
<p><img alt="teleweb" object-fit="contain" src="media/teleweb.png" width="80%"/></p>
<p>When you click on the target chat, the URL should change such that the chat ID is the <strong>suffix</strong> of the shown URL. While itâ€™s not always the case, if the chat is a <a href="https://telegram.org/blog/supergroups#supergroups">supergroup</a>, the chat ID should start with <code>-100</code>, like the image above. Now store this actual chat ID into a variable called <code>CHAT_ID</code>.</p>
<p>Next, all the API tokens youâ€™ve gotten from BotFather are to be stored as a list of strings called <code>TOKENS</code>. So, for now our Python script looks like this.</p>
<pre><code class="language-python">CHAT_ID = -10012345678
TOKENS = [
    "0123456789:abcdefgh_ijklmno",
    "0123456788:abcdefgh_ijklmnp",
    "0123456787:abcdefgh_ijklmnq",
    ... # fill it yourself
]
</code></pre>
<p>We continue by constructing the message that we want to send via the telebots. We can define a <code>get_message()</code> function so we can either send a constant message or a random choice from a set of messages. Here is an example.</p>
<pre><code class="language-python">from random import choice
def get_message():
    return choice(['Test', 'Wake up', 'ðŸ¥€'])
</code></pre>
<p>And then, the function to send the message itself, called <code>send_message</code>. I have made the function to be general enough so it takes in 3 parameters and an optional parameter:
- <code>token</code>: the bot token
- <code>chat_id</code>: the target chat ID
- <code>message</code>: the message to be sent
- (optional) <code>verbose</code>: whether to have a verbose logging from Telegram API or not, e.g. the reason why the message cannot be sent, or an acknowledgement that the message is successfully sent</p>
<p>The function makes use of the <code>requests</code> module and uses one of the API endpoints to send a message. The verbose logging will simply print the JSON response for readability. Note that since the <code>parse_mode</code> is currently set to <code>Markdown</code>, you can send messages that can be parsed in Markdown style, like bolds or italics. You can use other parse modes as well, but thatâ€™s up to you to explore.</p>
<pre><code class="language-python">def send_message(token, chat_id, message, verbose=False):
    r = requests.get(f"https://api.telegram.org/bot{token}/sendMessage", params={
        "chat_id": chat_id,
        "parse_mode": "Markdown",
        "text": message,
        "disable_web_page_preview": True,
    })
    if verbose:
        print(r.json())
</code></pre>
<p>Finally, the main function itself. We make use of the <code>threading</code> module that we have imported to parallelize the processes, and <code>time</code> to delay the process to <a href="https://github.com/python-telegram-bot/python-telegram-bot/wiki/Avoiding-flood-limits">avoid the rate limit</a>. The duration of the delay is experimental, but I find <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow><mn>3</mn></mrow><mrow><mi>n</mi></mrow></mfrac></mrow></math> seconds to be a good estimate. What this means is that the same bot is supposed to send another message after 3 seconds, so the number of messages sent by a particular bot in one minute isnâ€™t too many, but the target gets a constant flow of messages within a much quicker rate. You can also think of this as a round-robin style of sending a message to the same target chat.</p>
<pre><code class="language-python">def main(target_chat):
    while True:
        threads = [threading.Thread(target=send_message, args=(token, target_chat, get_message())) for token in TOKENS]
        for t in threads:
            t.start()
            time.sleep(3 / len(TOKENS))
        for t in threads:
            t.join()

main(CHAT_ID)
</code></pre>
<h4>Aftermath</h4>
<p>Combining everything explained above will yield a single Python script that you can just copy within a single click.</p>
<pre><code class="language-python">import requests, time, threading

CHAT_ID = -10012345678
TOKENS = [
    "0123456789:abcdefgh_ijklmno",
    "0123456788:abcdefgh_ijklmnp",
    "0123456787:abcdefgh_ijklmnq",
    ... # fill it yourself
]

from random import choice
def get_message():
    return choice(['Test', 'Wake up', 'ðŸ¥€'])

def send_message(token, chat_id, message, verbose=False):
    r = requests.get(f"https://api.telegram.org/bot{token}/sendMessage", params={
        "chat_id": chat_id,
        "parse_mode": "Markdown",
        "text": message,
        "disable_web_page_preview": True,
    })
    if verbose:
        print(r.json())

def main(target_chat):
    while True:
        threads = [threading.Thread(target=send_message, args=(token, target_chat, get_message())) for token in TOKENS]
        for t in threads:
            t.start()
            time.sleep(3 / len(TOKENS))
        for t in threads:
            t.join()

main(CHAT_ID)
</code></pre>
<p>Note that you can further customize the script, like storing chat IDs as a list instead of a single chat ID, and many more. For now, Iâ€™ll keep the script as is for educational purposes.</p>
<p>Now that weâ€™re all set, itâ€™s time for action and pester back the spammers.</p>
<p><img alt="spam" object-fit="contain" src="media/spam.png" width="40%"/></p>
<h3>Epilogue: 2025</h3>
<p>Now that these spam techniques are not so frequent anymore, I can still make use of the telebot army for other purposes. One I thought of recently was treating them as an alarm clock. Making use of the Telegram Desktop notification sound on my laptop, spamming myself with these bots should make sufficiently repetitive noises that would wake me up.</p>
<p>Guess what? It worked, at least for the whole week I was experimenting myself on. Itâ€™s silly, but itâ€™s honest work.</p>
<p>What I changed from the previous Python code is simply adding the <code>datetime</code> module to indicate in how long do I want the alarm to start being triggered. We also have to modify the main part slightly as shown below.</p>
<pre><code class="language-python">import requests, time, threading, datetime

... # same as above

# additional code starts here
now = datetime.datetime.now()
while time.time() &lt; (now + datetime.timedelta(hours=6, minutes=30)).timestamp():
    time.sleep(10)
    continue
# additional code ends here

main(CHAT_ID)
</code></pre>
<p>What the additional code above does is checking whether itâ€™s been 6.5 hours after you start running the code, and only after that timestamp has been passed it will trigger the spamming. The time checking is done every 10 seconds by adding the delay <code>time.sleep</code>. How cool is that?</p>
<p>Thatâ€™s all for now. Whatâ€™s next, you might ask? Nothing I can think of yet, but silly things make you live a little, for sure! Truly an absolute cinema.</p>
<p><img alt="cinema" object-fit="contain" src="media/cinema.jpg" width="40%"/></p></div></div>
</section>
<section id="footer">
<div class="container">
<ul class="copyright">
<li>Â© Russell Saerang 2025. All rights reserved.</li>
<li>Design: <a href="http://html5up.net" rel="noopener noreferrer" target="_blank">HTML5 UP</a></li>
<li>Illustration: <a href="http://linkedin.com" rel="noopener noreferrer" target="_blank">LinkedIn</a> and <a href="http://unsplash.com" rel="noopener noreferrer" target="_blank">Unsplash</a></li>
</ul>
</div>
</section>
</div>
<script src="../assets/js/jquery.min.js"></script>
<script src="../assets/js/jquery.scrollex.min.js"></script>
<script src="../assets/js/jquery.scrolly.min.js"></script>
<script src="../assets/js/browser.min.js"></script>
<script src="../assets/js/breakpoints.min.js"></script>
<script src="../assets/js/util.js"></script>
<script src="../assets/js/main.js"></script>
<link href="../assets/css/highlight.min.css" rel="stylesheet"/>
<script src="../assets/js/highlight.min.js"></script>
<script>hljs.highlightAll(); hljs.addPlugin(
        new CopyButtonPlugin({
            autohide: false,
            callback: (text, el) => console.log("Copied to clipboard", text),
    }));
</script>
</div></body>
</html>